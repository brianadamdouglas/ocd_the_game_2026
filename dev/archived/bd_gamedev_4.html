<!DOCTYPE html>
<html>
	<head>
		<title>Container inside a rotator v2</title>
		<link rel="stylesheet" type="text/css" href="../css/gameboard.css">
		<script src="js/jQuery_v2_1_3.js"></script>
		<script src="js/jquery.easing.1.3.js"></script>
		<script src="js/e-smart-hittest-jquery.js"></script>
		<script src="js/OSC.js"></script>
		<script src="js/gameBoard.js"></script>
		<script src="js/CLASS.js"></script>
		<script src="js/Tile.js"></script>
		<script src="js/InteractiveTile.js"></script>
		<script src="js/DoorTile.js"></script>
		<script src="js/animationFrame.js"></script>
		
		
		<style>
			
			.redBox { 	  position:absolute; 
					 	  width:50px;
						  height:50px;
						  background:red;	
			}
			
			
			#container{	  position:absolute;
						  width:700px;
						  height:900px;
						  left:0px;
						  top:0px;	
						  background:#fff;				  
			}
			
			#rotater{	  position:absolute;
						  width:600px;
						  height:600px;
						  left:0px;
						  top:0px;
						  transform-origin: 300px 300px;
						   -webkit-transform-origin: 300px 300px; /* Chrome, Safari, Opera */
						  
			}
			
			#character{	  position:absolute;
						  width:48px;
						  height:48px;
						  left:276px;
						  top:276px;
						  background-image: url("../img/gameDev/character.png");
						  background-repeat: no-repeat;
                          background-position: center ;
						  
						  
                          
    					  
			
			}
			
			#debug{		  position:absolute;
						  width:200px;
						  height:50px;
						  background:orange;
						  left:700px;
						  top:0px;
				
				
			}
			#mask{		  
						  position:absolute;
						  width:500px;
						  height:500px;
						  left:0px;
						  top:0px;
          				  clip: rect(150px,500px,500px,150px);
			}
			

			
			
			
		
		</style>
	</head>
	
	<body>
		<div id="mask"><div id='rotater'></div></div>
		<div id='character'></div>
		<script>
		
		/* build notes for tonight
		
			build an interactive javascript class that has a callback 
			should have an animated sequence
			should have an interacted state that sends a message back to the game
			
			
			get immediate matric AROUND CHARACTER FOR HIT TEST so that you have to check less.
		
		*/
		
			var row 	= 	0;
			var column 	= 	0;
			var colMax	= 	13;
			var rowMax	=	17;
			var angle = 0;
			var containerRotation = 0;
			var direction = 'horizontal';
			var canMoveForward = true;
			var divMDArray = Array();
			buildArray();
			addContainer();
			buildFloor();
			$(document).keypress(alertKey);
			
			
			function buildArray(){

				for(var i=0; i<rowMax ; i++){
					divMDArray.push(Array());
				}
			}
			
			function buildFloor(){
				var max = colMax * rowMax;
				for(var i = 0; i<max; i++){
					addSprite();
				}
			}
			
			
			function addContainer(){
				var newDiv = document.createElement('div');
				var id = "container";
				newDiv.id = id;
				O('rotater').appendChild(newDiv); 
			}
			
			
			function addSprite(){
				
				if(row<rowMax){
					if(column < colMax){
						//createNewSprite
						divMDArray[row].push(createSprite(row,column));
						column++;
					}else{
						row++;
						column = 0;
						addSprite();
					}
				}else{
				}
			}
			
			
			
			function createSprite(row,col){
				var classAcronym = gameboardMatrix[row][col];
				var className = gameBoardClasses[classAcronym];	
				var imagePath = gameBoardImageLookup[classAcronym];
				
				if (className.match(/interactive/gi) == null ){
					var newTile = new Tile();
				} else if(className.match(/door/gi) != null){
					var newTile = new DoorTile();
				}else{
					var newTile = new InteractiveTile();
				}
				var id = 'sprite'+"_"+row+"_"+col;
				var container = "container";		
				var x = (col * 50)+25;
				var y = (row * 50)+25;
				newTile.init(container, id, className, x, y,imagePath, 0);
				return {_name:newTile.getID(), _classReference:newTile};
				
				
			}
			
			function showName(){
				
		        var id = $(this).attr("id");
		
			}
			
			/* this is the only part we will change for mobile, use joystick instead of keypress*/
			function alertKey(event){
				key = (event.which)
				if(String.fromCharCode(key) == "x"){
					$('#rotater').finish();
					$('#container').finish();	
					rotateSpriteSheet(angle -= 180, 180);
				}
				if(String.fromCharCode(key) == "w"){
					$('#rotater').finish();
					$('#container').finish();
					correctMoveForward();
				}
				if(String.fromCharCode(key) == "a"){
					$('#rotater').finish();
					$('#container').finish();
					rotateSpriteSheet(angle += 90);
				}
				if(String.fromCharCode(key) == "d"){
					$('#rotater').finish();
					$('#container').finish();
					rotateSpriteSheet(angle -= 90);
				}
				/*button press / interact with object*/
				if(String.fromCharCode(key) == "s"){
					var predictedObject = checkForHit();
					var isInteractive = $('#' + predictedObject._name).hasClass( "interactive" );
					if(isInteractive){
						var classRef = predictedObject._classReference;
						classRef.actedUpon();
					}
				}
			}
			
			function checkForHit(){
				var hitObstacle = catchHit();
				if(hitObstacle[0]){
					canMoveForward = false;
				}else{
					canMoveForward = true;
				}
				return (hitObstacle[1]);
				
			
			}


			/*function catchHit(){ //v2
				//find position of character to matrix
				var position = $('#container').position();
				var loc = {x:position.left, y:position.top}
				var characterTileSize = 50;
				var centerPointRotater = 300;
				switch(containerRotation){
								case 0:
									var y =  -(loc.x - (centerPointRotater) );
									var x =  -(loc.y - (centerPointRotater) );
									break;
								case 90:
									var x =  (rowMax * 50)+(loc.x - (centerPointRotater - characterTileSize));
									var y =  -(loc.y - centerPointRotater );
									break;
								case 180:
									var y =  (colMax*50)+(loc.x - (centerPointRotater- characterTileSize));
									var x =  (rowMax*50)+(loc.y - (centerPointRotater- characterTileSize));							
									break;
								case 270:
									var x =  -(loc.x - (centerPointRotater));
									var y =  (colMax * 50) + (loc.y - (centerPointRotater- characterTileSize));
									break;
				}
				
				var point = [  Math.round((x - 50)/50), Math.round((y-50)/50) ];
				
				//find position of character to matrix
				
				//build target bounds
				var top = new Array(point[0] - 1, point[1]);
				var left = new Array(point[0], point[1]-1);
				var right = new Array(point[0], point[1]+1);
				var bottom = new Array(point[0]+ 1, point[1]);
				var center = new Array(point[0], point[1]);
				
				switch(containerRotation){
						case 0:
							var predict = divMDArray[top[0]][top[1]];
							//var predict = '#' + divMDArray[i-1][j]._name;
							break;
						case 90:
							var predict = divMDArray[left[0]][left[1]];
							//var predict = '#' + divMDArray[i][j-1]._name;
							break;
						case 180:
							var predict = divMDArray[bottom[0]][bottom[1]];
							//var predict = '#' + divMDArray[i+1][j]._name;
							break;
						case 270:
							var predict = divMDArray[right[0]][right[1]];
							//var predict = '#' + divMDArray[i][j+1]._name;
							break;
					}
					//console.log($('#' + predict._name).hasClass( "obstacle" ));
					
					if($('#' + predict._name).hasClass( "obstacle" )){
						// for doors check for a state called open. If open ignore and return false
						console.log(predict._classReference.getClass());
						return ([true, predict]);
					} else{
						return ([false, predict]);
					}
				
			}
			*/
			

			
			
			
			function catchHit(){
				//find position of character to matrix
				var position = $('#container').position();
				var loc = {x:position.left, y:position.top}
				var characterTileSize = 50;
				var centerPointRotater = 300;
				switch(containerRotation){
								case 0:
									var y =  -(loc.x - (centerPointRotater) );
									var x =  -(loc.y - (centerPointRotater) );
									break;
								case 90:
									var x =  (rowMax * 50)+(loc.x - (centerPointRotater - characterTileSize));
									var y =  -(loc.y - centerPointRotater );
									break;
								case 180:
									var y =  (colMax*50)+(loc.x - (centerPointRotater- characterTileSize));
									var x =  (rowMax*50)+(loc.y - (centerPointRotater- characterTileSize));							
									break;
								case 270:
									var x =  -(loc.x - (centerPointRotater));
									var y =  (colMax * 50) + (loc.y - (centerPointRotater- characterTileSize));
									break;
				}
				
				var point = [  x/50, y/50  ]
				console.log(Math.round(point[0]) + " | "+ Math.round(point[1]));
				
				//find position of character to matrix
				
				
				
				for(var i = 0; i<rowMax; i++){
					for(var j = 0; j<colMax; j++){
						var k = '#' + divMDArray[i][j]._name;
						var hit = $('#character').objectHitTest({"object":$(k)});
						if(hit){	
							switch(containerRotation){
								case 0:
									var predict = divMDArray[i-1][j];
									//var predict = '#' + divMDArray[i-1][j]._name;
									break;
								case 90:
									var predict = divMDArray[i][j-1];
									//var predict = '#' + divMDArray[i][j-1]._name;
									break;
								case 180:
									var predict = divMDArray[i+1][j];
									//var predict = '#' + divMDArray[i+1][j]._name;
									break;
								case 270:
									var predict = divMDArray[i][j+1];
									//var predict = '#' + divMDArray[i][j+1]._name;
									break;
							}
							if($('#' + predict._name).hasClass( "obstacle" )){
								// for doors check for a state called open. If open ignore and return false
								//console.log(predict._classReference.getClass());
								return ([true, predict]);
							} else{
								return ([false, predict]);
							}
						}
					}
				}
			}
			
			
			
			function rotateSpriteSheet(degrees, rot){
				var remainder = (degrees/360)%1;
				if(remainder < 0){
					var percent = 1 + remainder;	
				}else{
					var percent = remainder;
				}
				containerRotation = 360 * percent;
				if(rot != 180){
					var _duration = 300;
				}else{
					var _duration = 600;
				}
				
				$('#rotater').animate(
										{target: degrees}, 
											{step: function(now,fx) {
														$(this).css('-webkit-transform','rotate('+now+'deg)'); 
														$(this).css('-moz-transform','rotate('+now+'deg)');
														$(this).css('transform','rotate('+now+'deg)');
												   }
													,duration:_duration,
													easing:'easeOutCirc',
													complete:rotateSprite
											});
				
			}
			
			function correctMoveForward(position){
				if(canMoveForward){
					switch(containerRotation){
						case 0:
							$('#container').animate( {left:"+=0", top:"+=50" }, 100, 'swing',checkForHit);
							break;
						case 90:
							$('#container').animate( {left:"+=50", top:"+=0" }, 100, 'swing',checkForHit);
							break;
						case 180:
							$('#container').animate( {left:"+=0", top:"-=50" }, 100, 'swing',checkForHit);
							break;
						case 270:
							$('#container').animate( {left:"-=50", top:"+=0" }, 100, 'swing',checkForHit);
							break;
					}
				}
				
			}
			
			function rotateSprite(){
				checkForHit();
			}
			

			
			function getRotationDegrees(obj) {
 			   var matrix = obj.css("-webkit-transform") ||
			    obj.css("-moz-transform")    ||
			    obj.css("-ms-transform")     ||
			    obj.css("-o-transform")      ||
			    obj.css("transform");
			    if(matrix !== 'none') {
			        var values = matrix.split('(')[1].split(')')[0].split(',');
			        var a = values[0];
			        var b = values[1];
			        var angle = Math.round(Math.atan2(b, a) * (180/Math.PI));
			    } else { var angle = 0; }
			    return angle;
			}
			
			
			
			
		
		</script>
	
	</body>

</html>